<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <article>
        <section>
            <h5>Javascript Gold</h5>
            
            <p>Another student and a TA were working on a project for a while, and they figured out you can label a for loop (using similar syntax to a Javascript object).  One would be  able to break out of an above loop while in a nested loop.  You can also continue. </p>
            <h6>Break Example</h6>
            <pre>
                myForLoop:
                for (let i = 0; i < 5; i ++){
                    if(i === 2){
                        break myForLoop;
                    }
                    console.log(i);
                }

            </pre>
            <h6>Continue Example</h6>
            <p>I wonder how continue and break would differ in the example below.  After running them, it looks like <i>continue</i> goes back up to the top of the for loop that it is directed to and increments it, while <i>break</i> stops the the current loop and continues onto the code after it.</p>
            <pre>
                myForLoop:
                for (let i = 0; i < 5; i++){
                    if(i === 2){
                        for(let x = 0; x < 7; x++){
                            if(x === 3){
                                continue myForLoop;
                            }
                            console.log('x', x);
                        }
                    }
                    console.log('i', i);
                }
                // Output
                // i 0
                // i 1
                // x 0
                // x 1
                // x 2
                // i 3
                // i 4
            </pre>
            <pre>
                myForLoop:
                for (let i = 0; i < 5; i++){
                    if(i === 2){
                        for(let x = 0; x < 7; x++){
                            if(x === 3){
                                break;
                            }
                            console.log('x', x);
                        }
                    }
                    console.log('i', i);
                }
                // Output
                // i 0
                // i 1
                // x 0
                // x 1
                // x 2
                // i 2
                // i 3
                // i 4
                </pre>
            <h5><a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label'>MDN Docs Example</a></h5>
            <pre>
                let i, j;
                    
                    loop1:
                    for (i = 0; i < 3; i++) {      //The first for statement is labeled 'loop1'
                       loop2:
                       for (j = 0; j < 3; j++) {   //The second for statement is labeled 'loop2'
                          if (i === 1 && j === 1) {
                             break loop1;
                          }
                          console.log('i = ' + i + ', j = ' + j);
                       }
                    }
                    
                    // Output is:
                    //   'i = 0, j = 0'
                    //   'i = 0, j = 1'
                    //   'i = 0, j = 2'
                    //   'i = 1, j = 0'
                    // Notice the difference with the previous continue example</pre>
        </section>
        <section>
            <h5>Annoying Things Encountered</h5>
            <p>Learned that addEventListener (at least in the xample below) does not take arrow functions.  It will take anonymous functions, just not arrow functions.  I'm probably missing something.</p>
            <pre>
                function loadData(animal, outputId){
                    const xhr = new XMLHttpRequest();
                    xhr.open("GET", `${animal}Products.json`);

                    xhr.addEventListener("load", () => { // Does not work!

                        data = JSON.parse(this.responseText);
                        createTable(outputId, animal);
                    });
                    xhr.send();   
                }
            </pre>
            <pre>
                    Uncaught SyntaxError: Unexpected token u in JSON at position 0
            </pre>
            <pre>
                function loadData(animal, outputId){
                    const xhr = new XMLHttpRequest();
                    xhr.open("GET", `${animal}Products.json`);

                    xhr.addEventListener("load", function() { // Does work!

                        data = JSON.parse(this.responseText);
                        createTable(outputId, animal);
                    });
                    xhr.send();   
                }
            </pre>
        </section>
        <section>
            <h5>SASS</h5>
            <p>Today was the first day that I have worked in SASS.</p>
            <ul>
                <li>@mixin creates a function.  Refer to it with @include.</li>
                <li>@import imports another sass file.</li>
                <li>& refers to this.  $:hover</li>
                <li>% creates a function whose values cannot be changed.</li>
            </ul>
        </section>
        <section>
            <h5>Javascript Sort</h5>
            <p>To sort an array from largest to smallest, I see the below a lot on Google. </p>
            <pre>
                [34, 24, 29, 3].sort(function(a, b){return b - a});
            </pre>
            <p>After Joe Shepherd, the NSS instructor explained it, it looks like .sort feeds 34 and 24 as a and b, and returns the subtracted value of 10.  10 would mean that the second number is smaller than the first, so 24 would go after 34.  It repeats this until the numbers are greatest to smallest.  The next two numbers would be 24 and 29, which would return -5, so .sort would put 29 before 24.</p>

        </section>
        <section>
            <h5>Cool Things</h5>
            <p>Joe Shepherd, the NSS instructor, showed use the below code to augment a module.  The part I am intiuged by is the (tree || {}) statment at the bottom.  Meaning, if tree is false (it is undefined) then use an empty object as the argument, otherwise use tree.  This works, because if tree is undefined, it returns false.</p>
            <p>The fact that tree returns false if undefined interests me.  This is a basic building block in Javascript, and something that I would not have come up with by myself.  It makes me look at other syntax I take for granted, like an IIFE stament being enclosed in parenthesis in this example <span class='code'>(function() {
                alert('hey!');
            })();</span>  The parenthesis aren't just arbitrary syntax used to say 'hey! This is an IIFE!'  They are a basic building block, serving a basic function, used to create this IIFE statment.  </p>
            <p>The primary way it occurs to me to use it right now would be with function arguments.  If x isn't provided, then do this.  But I think there is other ways that this could be utilized.  </p>
            <pre>
                var tree = (function(originalTree) {
                    let randomVar = "protected";
                    
                    originalTree.outputToDOM = () => {
                        let myTree = tree.getTreeSpecies();
                        document.getElementById("myTree").innerHTML = `My fave tree is a ${
                        myTree
                        } tree`;
                    };
                    
                    return originalTree;
                    })(tree || {});
            </pre>
        </section>
        <section>
            <h5>Questions</h5>
            <ul>
                <li>Research Execution Context to have a greater understanding of <i>this</i> when using arrow functions.</li>
            </ul>
        </section>
    </article>

</body>
</html>